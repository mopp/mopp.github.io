Created: 2016-06-10  
Updated: 2016-06-10

# 02. ブートする
***



## 目標
Rustで書いたmain関数をブートする。
***



## OSはどのように呼び出されるのか
ブート(Boot)とは起動という意味の英語です。  
なので、PCの電源ボタンを押して、OSを起動させることをOSをブートさせるといいます。
ここでは、ブートについて見ていきます。

一般的なPCで電源を押して、OSが起動するまでの流れを以下に示します。  
電源ON -> BIOS起動 -> BIOSによるPOST -> ブートローダ起動 -> OS起動  
TODO: 図

BIOS(ばいおす)は、Basic Input/Output Systemの略称です。
はるか昔に、様々なデバイスを抽象化し、プログラムからうまいこと制御するために生まれたそうです。
しかし、コンピュータの普及に伴い、BIOSだけであらゆるデバイスに対応するのは不可能となったので、OSがデバイスドライバを用いて直接デバイスを制御するのが昨今のやり方です。
そして、BIOSが行うPOST(Power On Self Test)というのが、ハードウェアなどの初期化などを行う処理のことを指す言葉です。
PC起動時にビープ音がなるのがPOST処理らしいです。
その後に、ブートローダを読み込みます。
ここで、BIOSがどうやって起動するんだ？という疑問が生まれますが、マザーボードのROM(BIOSアップデートとかできるし、RAMというべき？)内に書き込まれており、電源が入ると自動的に実行されるそうです。
詳しくは知らないですが、ハードウェアで読み込み回路みたいなものがあるのかなと考えています。
***



## ブートローダ
次にBIOSから起動されるブートローダです。  
ブートローダ(Boot Loader)、もしくはブートストラップローダ(Bootstrap Loader)は、OSを起動するためのプログラムです。
ここでも、そのままBIOSにOSを読み込んで貰えば良くない？という疑問が生じますね。
しかし、BIOSは残念ながらディスクの先頭セクタ一つしか読み込んでくれないのです。
このディスクの先頭セクタを特別に**MBR(Master Boot Record)**と呼びます。  
ここで、BIOSが読むのは512バイト！と言われますが、正確には1セクタのサイズなので、512バイト固定ではありません。
ディスクシステムに依ります。
実際問題は、HDDのセクタは大抵512バイトなので、512バイトしかBIOSは読んでくれないんですけどね。

さて、勘のいい人ならもうお気づきですね。BIOSはブートローダを読み込む、しかし、それは1セクタ分…  
そうです、ブートローダは512バイトで作らなければならないのです。
更に、そこにはパーティションブロックが存在しなければならないので、実質446バイトのプログラムで済ませなければなりません。
最高の縛りプレイってやつです。
ここでは、ブートローダとしてgrubを使うので書きませんが、ギリギリのプログラム容量でいかに機能を詰め込むかなど大変おもしろいので、やって見る価値はあります。

512バイトのOSなんて不可能に決まっています。
なので、ブートローダはOSを読み込むためだけのプログラムです。
そのくらいなら書けそうじゃない？と思いますよね？
もちろん、書けないとは言いません。
自分も最初は自分で書いてやろうと思いました。
そして、気が付きます。
**ファイルっていうのはファイルシステムの中に格納される**ということに。
当たり前ですよね？OSのバイナリファイルを例えば/boot/kernelなんてファイルとして、HDDの中においておこうというのは自然な発想です。
そして、ここで更に気が付きます。あれ、512バイトでファイルシステムを書くって無理じゃん。
おそらくgrubなどは、OSを一気に読み込むのでなく、最初に起動されたブートローダでもう少し、高機能でファイルシステムを理解できるブートローダを読み出します。
そして、二段目のブートローダがOSをファイルシステムから読み込みます。
これを多段ブート方式と呼びます。
なかなか、めんどいですね。
それに、二段目のブートローダをどこに配置するか、なども問題です。(おそらくMBRの直後においてあるのかなあと)
これを自前で書くのは一苦労です。
なので、ここはおとなしくgrubを使いましょう。
***



## Multiboot specification 2
さてさて、それではgrubからOSをブートするためにはどうするのでしょうか。
答えは、Multiboot specification\[1\](面倒なので日本語でマルチブート仕様とします)を使います。
[2016-06-10時点で最新の仕様](http://git.savannah.gnu.org/cgit/grub.git/commit/?h=multiboot2&id=bb61b2b8010a14f09905522b053099996a1833d1)をPDFにしました。
* [Multiboot specification 2 PDF](/articles/os/multiboot2.pdf)

PDF化しただけで、一切の変更をしていません。
また、この仕様はGPL3でライセンスされています。  
リポジトリのブランチ名はmultiboot2なのに、なぜかPDF上では1.6になっています。
不思議ですが細かいことは気にしないで行きましょう。

仕様書より、マルチブート仕様の目的を引用します。
>原文: Basically, it specifies an interface between a boot loader and a operating system, such that any complying boot loader should be able to load any complying operating system.  
>訳:基本的に、仕様に準拠したブートローダが仕様に準拠したOSを読み込めるように、ブートローダとOS間のインターフェースを策定する。

様々なOSが様々な独自ブートローダを持っていて、複数のOSを共存させるのが難しい、多段ブートが悪夢のようになる(原文にそうあります)ということがマルチブート仕様策定の背景にあるようです。  
実際に、LinuxであればLILO(LInux LOader)、WindowsであればWindows Boot Managerなどがブートローダとして存在します。(ちなみに、Linuxはマルチブート仕様に対応しています。)
ブートローダはOSが実行に必要な情報(メモリ情報など)を集めて、OSに渡しますが、これが、それぞれどういうふうに渡すかが異なるため、LILOでWindowsを起動することは出来ません。  
うろ覚えですが、grubは、Linuxを起動したいときはLILOを起動、Windowsを起動したいときはWindows Boot Managerを起動、としていたはずです。  
これを多段ブートや、chainingなどといいます。このとき、ブートローダはgrubから起動されたとは気づかずに、BIOSから起動されたようになるため、複数のOSを起動できるわけです。
しかし、あまりエレガントな方法とは言い難いですよね。
grubの中の人も大変そうです。  

しかし、grubはマルチブート仕様に対応しています。
なので、遠慮なく使用させていただきましょう。
***


## OSのエントリーポイント
ここからやっとプログラムを書いていきます。
が、Rustではなく、アセンブラです。



### References
* \[1\]. Grub2 repository, [http://git.savannah.gnu.org/cgit/grub.git/tree/doc?h=multiboot2](http://git.savannah.gnu.org/cgit/grub.git/tree/doc?h=multiboot2)
* \[2\]. Multiboot, [http://wiki.osdev.org/Multiboot](http://wiki.osdev.org/Multiboot)
* \[3\]. Tips  マルチブート仕様, [http://softwaretechnique.jp/OS_Development/Tips/multi_boot.html](http://softwaretechnique.jp/OS_Development/Tips/multi_boot.html)
    * 参考になるので載せましたがmultiboot specification 1なので気をつけてください。
***
